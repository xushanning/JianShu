
131、分割回文串
给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。
输入: "aab"
[
 ["aa","b"],
 ["a","a","b"]
]

160、相交链表
编写一个程序，找到两个单链表相交的起始节点。


162、寻找峰值
峰值元素是指其值大于左右相邻值的元素。
输入: nums = [1,2,1,3,5,6,4]
输出: 1 或 5

171、Excel表列序号
给定一个Excel表格中的列名称，返回其相应的列序号。
输入: "ZY"
输出: 701

172、阶乘后的零
给定一个整数 n，返回 n! 结果尾数中零的数量。
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.

179、最大数
给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。
输入: [3,30,34,5,9]
9534330

190、颠倒二进制位
颠倒给定的 32 位无符号整数的二进制位。
输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000

191、位1的个数
编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

200、岛屿数量
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。


202、快乐数
编写一个算法来判断一个数 n 是不是快乐数。


204、计数质数
统计所有小于非负整数 n 的质数的数量。
输入: 10
输出: 4

215、数组中的第K个最大元素
在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4

226、翻转二叉树
翻转一棵二叉树。


242、有效的字母异位词
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
输入: s = "anagram", t = "nagaram"
输出: true


268、缺失数字
给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。
输入: [9,6,4,2,3,5,7,0,1]
输出: 8

283、移动零
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]

287、寻找重复数
给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。
输入: [3,1,3,4,2]
输出: 3

300、最长上升子序列
给定一个无序的整数数组，找到其中最长上升子序列的长度。
[10,9,2,5,3,7,101,18]
[2,3,7,101]
输出4

322、零钱兑换
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回
输入: coins = [1, 2, 5], amount = 11
输出: 3

326、3的幂
给定一个整数，写一个函数来判断它是否是 3 的幂次方。

350、 两个数组的交集 II
给定两个数组，编写一个函数来计算它们的交集。
输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2,2]

371、两整数之和
不使用运算符 + 和 - ，计算两整数 a 、b 之和。
a = 1, b = 2

378、有序矩阵中第K小的元素
给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

395、至少有K个重复字符的最长子串
找到给定字符串（由小写字符组成）中的最长子串 T ， 要求 T 中的每一字符出现次数都不少于 k 。输出 T 的长度。
输入：s = "ababbc", k = 2
输出：5
最长子串为 "ababb" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。

454、四数相加 II
给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]
输出 2
//1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
//2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0